module Vulkan

class VKSwapchain
  PROPERTIES
    context       : VKContext
    current_frame : VKFrameControl
    frames        = VKFrameControl[]
    images        = VKSwapchainImage[]
    surface_size  : XY

    native "VkSwapchainKHR native_swapchain;"

    cmd_pool   : VKCommandPool
    cmd_buffer : VKCommandBuffer

  METHODS
    method init( context, surface_size )

    method advance_frame
      current_frame = frames[ (frames.locate(current_frame).value + 1) % frames.count ]

    method configure
      if (context.surface.max_size.min == 0)
        context.is_prepared = false
        context.is_minimized = true
        return
      else
        context.is_minimized = false
      endIf

      ensure<<cmd_pool>>( context, context.graphics_queue_family )
      cmd_buffer = cmd_pool.create_command_buffer
      cmd_buffer.begin

      if (context.surface.size.x != -1) surface_size = context.surface.size
      surface_size .= clamped( context.surface.min_size, context.surface.max_size )

      local pre_transform = VKSurfaceTransform.IDENTITY
      if (not context.surface.supports_transform(pre_transform))
        pre_transform = context.surface.current_transform
      endIf

      local composite_alpha_type : VKCompositeAlphaType
      forEach (type in VKCompositeAlphaType.categories)
        if (context.surface.supports_composite_alpha_type(type))
          composite_alpha_type = type
          escapeForEach
        endIf
      endForEach

      local present_mode = VKPresentMode.FIFO

      local image_count = 3.clamped( context.surface.min_swapchain_image_count, context.surface.max_swapchain_image_count )
      images.clear

      native
        @|VkSwapchainKHR old_swapchain = $this->native_swapchain;
         |
         |VkSwapchainCreateInfoKHR swapchain_ci =
         |{
         |  .sType = VK_STRUCTURE_TYPE_SWAPCHAIN_CREATE_INFO_KHR,
         |  .pNext = NULL,
         |  .surface = $context->surface->native_surface.value,
         |  .minImageCount = $image_count,
         |  .imageFormat = $context->surface_format.native_format.value.format,
         |  .imageColorSpace = $context->surface_format.native_format.value.colorSpace,
         |  .imageExtent =
         |  {
         |    .width  = $surface_size.x,
         |    .height = $surface_size.y
         |  },
         |  .imageUsage = VK_IMAGE_USAGE_COLOR_ATTACHMENT_BIT,
         |  .preTransform = $pre_transform.value,
         |  .compositeAlpha = $composite_alpha_type.value,
         |  .imageArrayLayers = 1,
         |  .imageSharingMode = VK_SHARING_MODE_EXCLUSIVE,
         |  .queueFamilyIndexCount = 0,
         |  .pQueueFamilyIndices = NULL,
         |  .presentMode = $present_mode.value,
         |  .oldSwapchain = old_swapchain,
         |  .clipped = 1,
         |};
         |
         |$context->vkCreateSwapchainKHR.value( $context->device->native_device.value, &swapchain_ci, NULL, &$this->native_swapchain );
         |
         |if (old_swapchain != VK_NULL_HANDLE)
         |{
         |  $context->vkDestroySwapchainKHR.value( $context->device->native_device.value, old_swapchain, NULL );
         |}
         |
         |{
         |  uint32_t i, buffer_count;
         |  PFN_vkGetSwapchainImagesKHR get_swapchain_images = $context->vkGetSwapchainImagesKHR.value;
         |  get_swapchain_images( $context->device->native_device.value, $this->native_swapchain, &buffer_count, NULL );
         |
         |  if (buffer_count && buffer_count <= 8)
         |  {
         |    VkImage swapchain_images[8];
         |    get_swapchain_images( $context->device->native_device.value, $this->native_swapchain, &buffer_count, swapchain_images );
         |    for (i=0; i<buffer_count; ++i)
         |    {
         |      VkImageViewCreateInfo image_view_config =
         |      {
         |        .sType = VK_STRUCTURE_TYPE_IMAGE_VIEW_CREATE_INFO,
         |        .pNext = NULL,
         |        .flags = 0,
         |        .image = swapchain_images[i],
         |        .viewType = VK_IMAGE_VIEW_TYPE_2D,
         |        .format = $context->surface_format.native_format.value.format,
         |        .components =
         |        {
         |            .r = VK_COMPONENT_SWIZZLE_IDENTITY,
         |            .g = VK_COMPONENT_SWIZZLE_IDENTITY,
         |            .b = VK_COMPONENT_SWIZZLE_IDENTITY,
         |            .a = VK_COMPONENT_SWIZZLE_IDENTITY,
         |        },
         |        .subresourceRange =
         |        {
         |          .aspectMask = VK_IMAGE_ASPECT_COLOR_BIT,
         |          .baseMipLevel = 0,
         |          .levelCount = 1,
         |          .baseArrayLayer = 0,
         |          .layerCount = 1
         |        }
         |      };
         |
                local image = VKSwapchainImage( context, native("(VKNativeImage){swapchain_images[i]}")->VKNativeImage )
                images.add( image )
      native
        @|      vkCreateImageView( $context->device->native_device.value, &image_view_config, NULL, &$image->view.value );
         |    }
         |  }
         |}

    method create_semaphores
      forEach (i in 0..<2)
        frames.add( VKFrameControl(i,context) )
      endForEach
      current_frame = frames.first

    method reset
      (forEach in images).destroy
      cmd_buffer.destroy
      cmd_pool.destroy
      cmd_pool = null

    method dispatch_advance_frame [api]
      advance_frame

    method dispatch_create_semaphores [api]
      create_semaphores

endClass

class VKFrameControl
  PROPERTIES
    index   : Int32
    context : VKContext

    native "VkFence fence;"
    native "VkSemaphore image_acquired_semaphore;"
    native "VkSemaphore draw_complete_semaphore;"
    native "VkSemaphore image_ownership_semaphore;"

  METHODS
    method init( index, context )
      native
        @|VkFenceCreateInfo fence_config =
         |{
         |  .sType = VK_STRUCTURE_TYPE_FENCE_CREATE_INFO,
         |  .pNext = NULL,
         |  .flags = VK_FENCE_CREATE_SIGNALED_BIT
         |};
         |
         |VkSemaphoreCreateInfo sephamore_config =
         |{
         |  .sType = VK_STRUCTURE_TYPE_SEMAPHORE_CREATE_INFO,
         |  .pNext = NULL,
         |  .flags = 0
         |};
         |
         |VkDevice device = $context->device->native_device.value;
         |
         |vkCreateFence( device, &fence_config, NULL, &$this->fence );
         |
         |vkCreateSemaphore( device, &sephamore_config, NULL, &$this->image_acquired_semaphore );
         |vkCreateSemaphore( device, &sephamore_config, NULL, &$this->draw_complete_semaphore );
         |if ($context->uses_separate_presentation_queue)
         |{
         |  vkCreateSemaphore( device, &sephamore_config, NULL, &$this->image_ownership_semaphore );
         |}

    method block_until_ready
      local device = context.device
      native
        @|vkWaitForFences( $device->native_device.value, 1, &$this->fence, VK_TRUE, UINT64_MAX );
         |vkResetFences( $device->native_device.value, 1, &$this->fence );
endClass
