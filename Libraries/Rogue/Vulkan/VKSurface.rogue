module Vulkan

class VKSurface
  PROPERTIES
    is_cleaned_up  : Logical

    context        : VKContext

    native_surface : VKNativeSurface
    capabilities   : VKNativeSurfaceCapabilities

    formats        : VKSurfaceFormat[]
    present_modes  : VKPresentMode[]

  METHODS
    method init( context, native_surface )
      native
        @|$context->vkGetPhysicalDeviceSurfaceCapabilitiesKHR.value(
         |  $context->gpu->native_gpu.value, $native_surface.value, &$capabilities.value
         |);

    method current_transform->VKSurfaceTransform
      return VKSurfaceTransform( native("(RogueInt32)$capabilities.value.currentTransform")->Int32 )

    method destroy
      on_cleanup

    method formats->VKSurfaceFormat[]
      if (@formats) return @formats

      local result = VKSurfaceFormat[]
      native
        @|uint32_t count = 0;
         |PFN_vkGetPhysicalDeviceSurfaceFormatsKHR get_formats = $context->vkGetPhysicalDeviceSurfaceFormatsKHR.value;
         |get_formats( $context->gpu->native_gpu.value, $native_surface.value, &count, NULL);
         |if (count && count <= 200)
         |{
         |  VkSurfaceFormatKHR formats[200];
         |  int i;
         |  get_formats( $context->gpu->native_gpu.value, $native_surface.value, &count, formats);
         |  for (i=0; i<count; ++i)
         |  {
              result.add( VKSurfaceFormat( native("(VKNativeSurfaceFormat){formats[i]}")->VKNativeSurfaceFormat ) )
      native
        @|  }
         |}

         @formats = result
         return @formats

    method max_buffer_count->Int32
      return VKSurfaceTransform( native("(RogueInt32)$capabilities.value.maxImageCount")->Int32 )

    method max_size->XY
      local w, h : Int32
      native
        @|$w = (RogueInt32) $capabilities.value.maxImageExtent.width;
         |$h = (RogueInt32) $capabilities.value.maxImageExtent.height;
      return XY( w, h )

    method min_buffer_count->Int32
      return VKSurfaceTransform( native("(RogueInt32)$capabilities.value.minImageCount")->Int32 )

    method min_size->XY
      local w, h : Int32
      native
        @|$w = (RogueInt32) $capabilities.value.minImageExtent.width;
         |$h = (RogueInt32) $capabilities.value.minImageExtent.height;
      return XY( w, h )

    method on_cleanup
      if (is_cleaned_up) return
      is_cleaned_up = true
trace "----"
      native @|vkDestroySurfaceKHR( $context->instance->native_instance.value, $this->native_surface.value, NULL );

    method present_modes->VKPresentMode[]
      if (@present_modes) return @present_modes

      local result = VKPresentMode[]
      native
        @|{
         |  PFN_vkGetPhysicalDeviceSurfacePresentModesKHR get_modes = $context->vkGetPhysicalDeviceSurfacePresentModesKHR.value;
         |  uint32_t count = 0;
         |
         |  get_modes( $context->gpu->native_gpu.value, $native_surface.value, &count, NULL );
         |  if (count && count <= 32)
         |  {
         |    VkPresentModeKHR modes[32];
         |    int i;
         |    get_modes( $context->gpu->native_gpu.value, $native_surface.value, &count, modes );
         |    for (i=0; i<count; ++i)
         |    {
                local mode : Int32
      native
        @|      $mode = (RogueInt32) modes[i];
                result.add( VKPresentMode(mode) );
      native
        @|    }
         |  }
         |}

         @present_modes = result

      return @present_modes

    method size->XY
      local w, h : Int32
      native
        @|$w = (RogueInt32) $capabilities.value.currentExtent.width;
         |$h = (RogueInt32) $capabilities.value.currentExtent.height;
      return XY( w, h )

    method supports_composite_alpha_type( type:VKCompositeAlphaType )->Logical
      return (type->Int32 & native("(RogueInt32)$capabilities.supportedCompositeAlpha")->Int32)?

    method supports_transform( transform:VKSurfaceTransform )->Logical
      return (transform->Int32 & native("(RogueInt32)$capabilities.supportedTransforms")->Int32)?

endClass
