module Vulkan

class VKDevice
  PROPERTIES
    context       : VKContext
    native_device : VKNativeDevice

    native "VkQueue graphics_queue;"
    native "VkQueue presentation_queue;"

  METHODS
    method init( config:VKDeviceConfig )
      context = config.context

      native
        @|float queue_priorities[1] = {0.0};
         |const char* extension_names[64];
         |
         |VkDeviceQueueCreateInfo queues[2];
         |queues[0].sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
         |queues[0].pNext = NULL;
         |queues[0].queueFamilyIndex = $context->graphics_queue_family.index;
         |queues[0].queueCount = 1;
         |queues[0].pQueuePriorities = queue_priorities;
         |queues[0].flags = 0;

      forEach (extension_name at i in config.enabled_extensions)
        native @|extension_names[$i] = $extension_name->data->as_utf8;
      endForEach

      native
        @|
         |VkDeviceCreateInfo device_info =
         |{
         |  .sType = VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO,
         |  .pNext = NULL,
         |  .queueCreateInfoCount = 1,
         |  .pQueueCreateInfos = queues,
         |  .enabledLayerCount = 0,
         |  .ppEnabledLayerNames = NULL,
         |  .enabledExtensionCount = $config->enabled_extensions->count,
         |  .ppEnabledExtensionNames = extension_names,
         |  .pEnabledFeatures = NULL,  // If specific features are required, pass them in here
         |};
         |
         |if ($context->uses_separate_presentation_queue)
         |{
         |  queues[1].sType = VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO;
         |  queues[1].pNext = NULL;
         |  queues[1].queueFamilyIndex = $context->presentation_queue_family.index;
         |  queues[1].queueCount = 1;
         |  queues[1].pQueuePriorities = queue_priorities;
         |  queues[1].flags = 0;
         |  device_info.queueCreateInfoCount = 2;
         |}
         |
         |vkCreateDevice( $context->gpu->native_gpu.value, &device_info, NULL, &$native_device.value );
         |

      native
        @|
         |vkGetDeviceQueue( $native_device.value, $context->graphics_queue_family.index, 0, &$this->graphics_queue );
         |if ($context->uses_separate_presentation_queue)
         |{
         |  vkGetDeviceQueue( $native_device.value, $context->presentation_queue_family.index, 0, &$this->presentation_queue );
         |}
         |else
         |{
         |  $this->presentation_queue = $this->graphics_queue;
         |}

      SET_NATIVE_PROCEDURE<<context,this,vkCreateSwapchainKHR>>
      SET_NATIVE_PROCEDURE<<context,this,vkDestroySwapchainKHR>>
      SET_NATIVE_PROCEDURE<<context,this,vkGetSwapchainImagesKHR>>
      SET_NATIVE_PROCEDURE<<context,this,vkAcquireNextImageKHR>>
      SET_NATIVE_PROCEDURE<<context,this,vkQueuePresentKHR>>

    method allocate_memory( size:Int32, mem_types:Int32,
        property_requirements=VKMemoryProperty.DEVICE_LOCAL:VKMemoryProperty )->VKNativeDeviceMemory
      local native_memory : VKNativeDeviceMemory
      local mem_index = context.gpu.memory_type_index( mem_types, property_requirements )

      native
        @|
         |VkMemoryAllocateInfo alloc_info =
         |{
         |  .sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
         |  .pNext = NULL,
         |  .allocationSize = $size,
         |  .memoryTypeIndex = $mem_index
         |};
         |
         |vkAllocateMemory( $native_device.value, &alloc_info, NULL, &$native_memory.value );

      return native_memory

    method create_buffer( size:Int32, usage:VKBufferUsage,
        required_properties=VKMemoryProperty[HOST_VISIBLE,HOST_COHERENT]:VKMemoryProperty, &concurrent )->VKBuffer
      return VKBuffer( context, size, usage, required_properties, &=concurrent )

    method procedure_address( name:String )->RogueVoidPointer
      local result : RogueVoidPointer
      native @|$result.value = $context->vkGetDeviceProcAddr.value( $native_device.value, $name->data->as_utf8 );
      return result

      #method swapchain_images->VKSwapchainImage
endClass
