module Vulkan

class VKBuffer
  PROPERTIES
    context       : VKContext
    native_buffer : VKNativeBuffer
    native_memory : VKNativeDeviceMemory

  METHODS
    method init( context, size:Int32, usage:VKBufferUsage,
        memory_requirements=VKMemoryProperty.HOST_VISIBLE|VKMemoryProperty.HOST_COHERENT, &concurrent )
      native
        @|VkDevice device = $context->device->native_device.value;
         |
         |VkBufferCreateInfo buffer_config =
         |{
         |  .sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
         |  .pNext = NULL,
         |  .flags = 0,
         |  .size = $size,
         |  .usage = $usage.value,
         |  .sharingMode = $concurrent ? VK_SHARING_MODE_CONCURRENT : VK_SHARING_MODE_EXCLUSIVE,
         |  .queueFamilyIndexCount = 0,
         |  .pQueueFamilyIndices = NULL
         |};
         |
         |vkCreateBuffer( device, &buffer_config, NULL, &native_buffer.value );
         |
         |VkMemoryRequirements mem_reqs;
         |vkGetBufferMemoryRequirements( device, native_buffer.value, &mem_reqs );
         |
         |VkMemoryAllocateInfo alloc_info =
         |{
         |  .sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
         |  .pNext = NULL,
         |  .allocationSize = mem_reqs.size,
         |  .memoryTypeIndex = 0
         |};
         |
         |VkFlags requirements = VK_MEMORY_PROPERTY_HOST_VISIBLE_BIT | VK_MEMORY_PROPERTY_HOST_COHERENT_BIT;
         |pass = memory_type_from_properties(demo, mem_reqs.memoryTypeBits, requirements, &tex_obj->mem_alloc.memoryTypeIndex);
         |assert(pass);
         |
         |err = vkAllocateMemory(DEMO_DEVICE, &tex_obj->mem_alloc, NULL, &(tex_obj->mem));
         |assert(!err);
         |demo_name_object(demo, VK_OBJECT_TYPE_DEVICE_MEMORY, (uint64_t)tex_obj->mem, "TexBufMemory(%s)", filename);
         |
         |/* bind memory */
         |err = vkBindBufferMemory(DEMO_DEVICE, tex_obj->buffer, tex_obj->mem, 0);
         |assert(!err);
endClass
