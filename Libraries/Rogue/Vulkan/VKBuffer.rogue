module Vulkan

class VKBuffer
  PROPERTIES
    context         : VKContext
    allocation_size : Int32
    native_buffer   : VKNativeBuffer
    native_memory   : VKNativeDeviceMemory

  METHODS
    method init( context, size:Int32, usage:VKBufferUsage,
        required_properties=VKMemoryProperty[HOST_VISIBLE,HOST_COHERENT]:VKMemoryProperty, &concurrent )
      local mem_types      : Int32

      native
        @|VkDevice device = $context->device->native_device.value;
         |
         |VkBufferCreateInfo buffer_config =
         |{
         |  .sType = VK_STRUCTURE_TYPE_BUFFER_CREATE_INFO,
         |  .pNext = NULL,
         |  .flags = 0,
         |  .size = $size,
         |  .usage = $usage.value,
         |  .sharingMode = $concurrent ? VK_SHARING_MODE_CONCURRENT : VK_SHARING_MODE_EXCLUSIVE,
         |  .queueFamilyIndexCount = 0,
         |  .pQueueFamilyIndices = NULL
         |};
         |
         |vkCreateBuffer( device, &buffer_config, NULL, &$native_buffer.value );
         |
         |VkMemoryRequirements mem_reqs;
         |vkGetBufferMemoryRequirements( device, $native_buffer.value, &mem_reqs );
         |$mem_types = mem_reqs.memoryTypeBits;
         |$allocation_size = mem_reqs.size;

         local mem_type_index = context.gpu.memory_type_index( mem_types, required_properties )

      native
        @|VkMemoryAllocateInfo alloc_info =
         |{
         |  .sType = VK_STRUCTURE_TYPE_MEMORY_ALLOCATE_INFO,
         |  .pNext = NULL,
         |  .allocationSize = $allocation_size,
         |  .memoryTypeIndex = $mem_type_index
         |};
         |
         |vkAllocateMemory( device, &alloc_info, NULL, &$native_memory.value );
         |vkBindBufferMemory( device, $native_buffer.value, $native_memory.value, 0 );

    method on_cleanup
      native @|VkDevice device = $context->device->native_device.value;

      if (native_buffer)
        native @|vkDestroyBuffer( device, $native_buffer.value, NULL );
                |$native_buffer.value = NULL;
      endIf

      if (native_memory)
        native @|vkFreeMemory( device, $native_memory.value, NULL );
                |$native_memory.value = NULL;
      endIf

    method destroy
      on_cleanup

    method map( offset=0:Int32, size=null:Int32? )->RogueVoidPointer
      local pointer : RogueVoidPointer
      native
        @|VkDevice device = $context->device->native_device.value;
         |vkMapMemory( device, $native_memory.value, $offset, ($size.exists)?($size.value):(VK_WHOLE_SIZE), 0, &$pointer.value );
      return pointer

    method set( bitmap:Bitmap )
      local size = bitmap.size.product * 4
      native
        @|VkDevice device = $context->device->native_device.value;
         |void* data;
         |
         |vkMapMemory( device, $native_memory.value, 0, $allocation_size, 0, &data );
         |memcpy( data, $bitmap->pixels->data, $size );
         |vkUnmapMemory( device, $native_memory.value );

    method unmap
      native
        @|VkDevice device = $context->device->native_device.value;
         |vkUnmapMemory( device, $native_memory.value );
endClass
