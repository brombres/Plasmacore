module Bitmap
uses Plasmacore

augment Bitmap
  GLOBAL METHODS
    method create( asset:Asset )->Bitmap
      return Bitmap( asset->File )

    method decode( bytes:Byte[] )->Bitmap
      # Use native layer/OS PNG/JPEG decoder
      nativeHeader
        struct RogueClassBitmap__Bitmap;
        RogueClassBitmap__Bitmap* Bitmap_decode_image( RogueByte* bytes, RogueInt32 count );
      endNativeHeader
      local bitmap = native( "Bitmap_decode_image( $bytes->data->as_bytes, $bytes->count )" )->Bitmap
      if (not bitmap) return Bitmap(1,1).[ error=true ]
      bitmap.swap_red_and_blue
      bitmap.is_premultiplied_alpha = true
      return bitmap

  METHODS
    method to_png_bytes->Byte[]
      nativeHeader
        struct RogueByte_List;
        bool Bitmap_to_png_bytes( RogueClassBitmap__Bitmap* bitmap, RogueByte_List* bytes );
      endNativeHeader

      # macOS (and iOS?) only works with bitmaps that have premultiplied alpha - it
      # unmultiplies them as it creates the output bytes. If we're not already premultiplied
      # we'll clone a copy of this bitmap to avoid the integer division rounding errors
      # that would result from premultiply > unmultiply
      local bitmap = which{ is_premultiplied_alpha:this || cloned }
      bitmap.premultiply_alpha
      bitmap.swap_red_and_blue

      local result = Byte[]
      native @|Bitmap_to_png_bytes( $bitmap, $result );

      bitmap.swap_red_and_blue
      return result

    method to_jpeg_bytes( quality=75:Int32 )->Byte[]
      nativeHeader
        struct RogueByte_List;
        bool Bitmap_to_jpeg_bytes( RogueClassBitmap__Bitmap* bitmap, RogueByte_List* bytes );
      endNativeHeader

      swap_red_and_blue

      local result = Byte[]
      native @|Bitmap_to_jpeg_bytes( $this, $result );

      swap_red_and_blue
      return result


endAugment

