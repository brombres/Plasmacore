module Plasmacore

class Texture
  PROPERTIES
    id           : Int32
    asset        : Asset
    bitmap       : Bitmap

    is_loaded    = false

    image_size   : XY  # equal to or a subset of texture_size
    texture_size : XY

  METHODS
    method init( asset, texture_size=XY(0,0):XY )
      id = TextureManager.next_id
      ++TextureManager.next_id
      image_size = texture_size
      load_async

    method init( bitmap:Bitmap )
      id = TextureManager.next_id
      ++TextureManager.next_id
      set( bitmap )

    method load_async
      # Asynchronous load; .is_loaded set to true when complete.
      if (not is_loaded) TextureManager.pending_textures.add( this )

    method load_from_bitmap
      local pixels = bitmap.pixels
      local width  = bitmap.width
      local height = bitmap.height

      bitmap.swap_red_and_blue
      nativeHeader
        void Texture_update( RogueInt32 texture_id, RogueInt32 width, RogueInt32 height, RogueByte* bytes );
      endNativeHeader

      native @|Texture_update( $id, $width, $height, $pixels->data->as_bytes );
      bitmap.swap_red_and_blue

      texture_size = XY(width,height)
      if (image_size.is_zero) image_size = texture_size
      is_loaded = true

    method on_cleanup
      unload

    method on_load( m:Message )
      if (m.read_logical)
        local w = m.read_int32x
        local h = m.read_int32x
        texture_size = XY(w,h)
        if (image_size.is_zero) image_size = texture_size
        is_loaded = true
      elseIf (asset)
        println "Error loading $"(asset.filepath)
      else
        println "Error converting bitmap to texture."
      endIf

    method set( bitmap )
      is_loaded = false
      if (Plasmacore.is_rendering)
        load_from_bitmap
      else
        load_async
      endIf

    method size->XY
      return image_size

    method unload
      if (is_loaded)
        Message( "Texture.unload" ).[ write_int32x(id) ].send
        is_loaded = false
      endIf

    method uv->Box
      return Box( image_size / texture_size )

endClass

class TextureManager [singleton]
  PROPERTIES
    next_id          = 1
    pending_textures = Texture[]
    loading_textures = Table<<Int32,Texture>>()

  METHODS
    method init
      MessageListener["Texture.on_load"] =
        function( m:Message )
          TextureManager.on_load( m )
        endFunction

    method all_textures_loaded->Logical
      return (pending_textures.is_empty and loading_textures.is_empty)

    method load_pending
      if (pending_textures.count)
        forEach (texture in pending_textures)
          if (texture.asset)
            if (texture.asset.confirm_exists)
              local q = Canvas.render_queue
              q.write( RenderCmd.LOAD_TEXTURE )
              q.write_int32x( texture.id )
              q.write_string( texture.asset.filepath )
              loading_textures[ texture.id ] = texture
            endIf
          else
            texture.load_from_bitmap
          endIf
        endForEach
        pending_textures.clear
      endIf

    method on_load( m:Message )
      local id = m.read_int32x
      local texture = loading_textures.remove( id )
      if (texture) texture.on_load( m )
endClass

