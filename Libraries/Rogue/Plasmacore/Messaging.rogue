module Plasmacore

$essential Byte[].clear()
$essential Byte[].reserve(Int32)

class MessageManager [singleton]
  PROPERTIES
    next_id         = 1
    listeners       = StringTable<<Function(Message)>>()
    reply_listeners = Table<<Int32,Function(Message)>>()

  METHODS
    method init
      set_listener( "",
        # Reply listener
        function(m:Message)
          local callback = MessageManager.reply_listeners.remove( m.message_id )
          if (callback) callback( m )
        endFunction
      )

    method message->Message [essential]
      return Message()

    method receive_message( m:Message )->Byte[] [essential]
      if (m.type.count == 0)
        local listener = reply_listeners.remove( m.message_id )
        if (listener) listener( m )
        return null

      else
        local listener = listeners[ m.type ]
        if (not listener)
          return null
        endIf

        listener( m )

        if (m.m_reply)
          if (m.m_reply.send_requested)
            local result = m.m_reply.data
            return result
          else
            m.m_reply.defer_reply = false  # a later send() will actually dispatch the reply
          endIf
        endIf
        return null

      endIf

    method set_listener( type:String, listener:Function(Message) )
      listeners[ type ] = listener

endClass

class Message
  PROPERTIES
    message_id     : Int32
    type           = StringBuilder()
    data           = Byte[]
    position       : Int32   # for reading
    m_reply        : Message
    defer_reply    = false
    send_requested = false

  GLOBAL METHODS
    method create( type:String )->Message
      local m = MessageManager.message

      m.message_id = MessageManager.next_id
      ++MessageManager.next_id
      m.type.print( type )

      m.write_int32x( m.message_id )
      m.write_string( type )

      return m

    method create( message_id:Int32 )->Message
      local m = MessageManager.message
      m.init_reply( 0 )
      return m

    method create( data:Byte[] )->Message
      local m = MessageManager.message

      m.data.add( data )
      m.message_id = m.read_int32x
      m.type.[clear].print( m.read_string )

      return m

  METHODS
    method init
      position = 0
      data.clear
      type.clear
      m_reply = null
      defer_reply = false
      send_requested = false

    method init_from_data [essential]
      position = 0
      m_reply = null
      message_id = read_int32x
      type.[clear].print( read_string )

    method init_reply( message_id )
      init
      write_int32x( message_id )
      write_int32x( 0 )  # empty string for message type

    method description->String
      if (type.count == 0) return "[response]"
      else                 return type

    method read_byte->Int32
      if (position >= data.count) return 0
      local result = data[ position ]
      ++position
      return result

    method read_logical->Logical
      return read_byte?

    method read_int32->Int32
      local result = read_byte :<<: 24
      result |= read_byte :<<: 16
      result |= read_byte :<<: 8
      return result | read_byte

    method read_int32x->Int32
      # Reads a variable-length encoded value that is stored in 1..5 bytes.
      # Encoded values are treated as signed.
      #
      # - If the first two bits are not "10" then the first byte is cast to
      #   a signed integer value and returned. This allows for the range
      #   -64..127 using the following bit patterns:
      #
      #     0xxxxxxx    0 .. 127
      #     11xxxxxx  -64 ..  -1
      #
      # - If the first two bits are "10" then the data has been encoded
      #   in the next 6 bits as well as any number of following bytes,
      #   (up to 4 additional) using 7 data bits per byte with an MSBit
      #   of 0 representing a halt or 1 a continuation. The next bit after
      #   the leading 10 in the first byte is treated as negative magnitude.
      #
      #     10xxxxxx 0yyyyyyy            (13-bit number xxxxxxyyyyyyy)
      #     10xxxxxx 1yyyyyyy 0zzzzzzz   (20-bit number xxxxxxyyyyyyyzzzzzzz)
      #     etc.
      local b = read_byte
      if ((b & 0xc0) != 0x80) return b->Byte.signed

      local result = (b & 0b0011_1111) #  0..63  (positive)
      if (result >= 32) result -= 64   # -64..63 (negative)

      loop 4  # up to 4 more bytes
        local next = read_byte
        result = (result :<<: 7) | (next & 0b0111_1111)
        if (not (next & 0b1000_0000)) escapeLoop
      endLoop

      return result

    method read_real32->Real32
      return read_int32.real_bits

    method read_real64->Real64
      local bits = read_int32->Int64 :<<: 32
      return (bits | read_int32).real_bits

    method read_string->String
      use builder = StringBuilder.pool
        read_string( builder )
        return builder->String
      endUse

    method read_string( builder:StringBuilder )
      local n = read_int32x
      if (not n) return

      local limit = data.count
      builder.reserve( n )
      loop n
        if (position >= limit) return
        builder.print( read_byte->Character )
      endLoop

    method reply( reuse=null:Message )->Message
      if (not m_reply)
        if (type.count == 0) throw Error( "Message: cannot reply to a reply." )
        if (reuse)           m_reply = reuse.[ init_reply(message_id) ]
        else                    m_reply = Message( message_id )
        m_reply.defer_reply = this.defer_reply
      endIf
      return m_reply

    method send->Message
      nativeHeader struct RogueByte_List;
      nativeHeader bool NativeInterface_send_message( RogueByte_List* bytes );

      if (send_requested) return null
      send_requested = true
      if (defer_reply) return null

      local has_reply : Logical
      native @|$has_reply = NativeInterface_send_message( $this->data );
      if (has_reply)
        init_from_data  # reply has been placed in same Byte[] buffer
        return this
      else
        return null
      endIf

    method send_rsvp( callback:Function(Message) )
      local reply = send
      if (reply)
        # Immediate reply
        callback( reply )
      else
        # Asynchronous reply
        MessageManager.reply_listeners[ message_id ] = callback
      endIf

    method to->Byte[]
      return data

    method write_byte( value:Int32 )
      data.add( value )

    method write_bytes( bytes:Byte[] )
      data.reserve( bytes.count + 4 )
      write_int32( bytes.count )
      data.data.set( data.count, bytes.data, 0, bytes.count )
      data.count += bytes.count

    method write_int32( value:Int32 )
      # Writes 4 bytes in high-low order, e.g. 0x12345678 -> [12,34,56,78]
      data.add( value:>>>:24 )
      data.add( value:>>>:16 )
      data.add( value:>>>:8 )
      data.add( value )

    method write_int32x( value:Int32 )
      # Writes a variable-length encoded value that is stored in 1..5 bytes.
      # See read_int32x() for more details.
      if (value >= -64 and value < 128)
        data.add( value )
      else
        local extra_bytes = 1
        local shift = 7
        local min = -0x1000
        local max =  0x0FFF
        loop 3
          if (value >= min and value <= max) escapeLoop
          ++extra_bytes
          shift += 7
          min = min :<<: 7
          max = (max :<<: 7) | 0xFF
        endLoop
        data.add( 0b10_000000 | ((value:>>>:shift)&0b11_1111) )
        loop extra_bytes-1
          shift -= 7
          data.add( 0b1000_0000 | ((value:>>>:shift) & 0b0111_1111) )
        endLoop
        shift -= 7
        data.add( (value:>>>:shift) & 0b0111_1111 )
      endIf

    method write_logical( value:Logical )
      data.add( which{value:1 || 0} )

    method write_real32( value:Real32 )
      write_int32( value.integer_bits )

    method write_real64( value:Real64 )
      local bits = value.integer_bits
      write_int32( bits :>>: 32 )
      write_int32( bits )

    method write_string( value:String )
      write_int32x( value.count )
      write_int32x( forEach in value )

endClass

class MessageListener [singleton]
  # Convenience class
  METHODS
    method set( message_type:String, listener:Function(Message) )
      MessageManager.set_listener( message_type, listener )
endClass

