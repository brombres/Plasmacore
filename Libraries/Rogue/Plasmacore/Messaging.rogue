module Plasmacore

$essential Byte[].clear()
$essential Byte[].reserve(Int32)

class MessageManager
  GLOBAL PROPERTIES
    next_id  = 1
    pool     = Message[]

  GLOBAL METHODS
    method message->Message
      if (pool.count) return pool.remove_last.[ init ]
      return Message()

endClass

class Message
  PROPERTIES
    message_id : Int32
    timestamp  : Real64
    data       = Byte[]
    position   : Int32   # for reading
    ref_count  : Int32
    m_reply    : Message

  GLOBAL METHODS
    method create( type:String )->Message
      local m = MessageManager.message

      m.message_id = MessageManager.next_id
      ++MessageManager.next_id

      m.write_real64( m.timestamp )
      m.write_int32x( m.message_id )
      m.write_string( type )

      return m

    method create( message_id:Int32 )->Message
      local m = MessageManager.message

      m.message_id = message_id

      m.write_real64( m.timestamp )
      m.write_int32x( m.message_id )
      m.write_int32x( 0 )  # empty string for message type

      return m

    method create( data:Byte[] )->Message
      local m = MessageManager.message

      m.data.add( data )
      m.timestamp = m.read_real64
      m.message_id = m.read_int32x

      return m

  METHODS
    method init
      timestamp = System.time
      position = 0
      data.clear
      ref_count = 0
      m_reply = null

    method init_from_data
      position = 0
      ref_count = 0
      m_reply = null
      timestamp  = read_real64
      message_id = read_int32x

    method is_type( type:String )->Logical
      position = 0
      read_int32x  # Message ID
      read_real64  # Timestamp
      local n = read_int32x
      if (n != type.count) return false
      if (read_int32x != forEach in type) return false
      return true

    method read_byte->Int32
      if (position >= data.count) return 0
      local result = data[ position ]
      ++position
      return result

    method read_int32->Int32
      local result = read_byte :<<: 24
      result |= read_byte :<<: 16
      result |= read_byte :<<: 8
      return result | read_byte

    method read_int32x->Int32
      # Reads a variable-length encoded value that is stored in 1..5 bytes.
      # Encoded values are treated as signed.
      #
      # - If the first two bits are not "10" then the first byte is cast to
      #   a signed integer value and returned. This allows for the range
      #   -64..127 using the following bit patterns:
      #
      #     0xxxxxxx    0 .. 127
      #     11xxxxxx  -64 ..  -1
      #
      # - If the first two bits are "10" then the data has been encoded
      #   in the next 6 bits as well as any number of following bytes,
      #   (up to 4 additional) using 7 data bits per byte with an MSBit
      #   of 0 representing a halt or 1 a continuation. The next bit after
      #   the leading 10 in the first byte is treated as negative magnitude.
      #
      #     10xxxxxx 0yyyyyyy            (13-bit number xxxxxxyyyyyyy)
      #     10xxxxxx 1yyyyyyy 0zzzzzzz   (20-bit number xxxxxxyyyyyyyzzzzzzz)
      #     etc.
      local b = read_byte
      if ((b & 0xc0) != 0x80) return b->Byte.signed

      local result = (b & 0b0011_1111) #  0..63  (positive)
      if (result >= 32) result -= 64   # -64..63 (negative)

      loop 4  # up to 4 more bytes
        local next = read_byte
        result = (result :<<: 7) | (next & 0b0111_1111)
        if (not (next & 0b1000_0000)) escapeLoop
      endLoop

      return result

    method read_real64->Real64
      local bits = read_int32->Int64 :<<: 32
      return (bits | read_int32).real_bits

    method read_string->String
      use builder = StringBuilder.pool
        read_string( builder )
        return builder->String
      endUse

    method read_string( builder:StringBuilder )
      local n = read_int32x
      if (not n) return

      local limit = data.count
      builder.reserve( n )
      loop n
        if (position >= limit) return
        builder.print( read_byte->Character )
      endLoop

    method recycle
      if (MessageManager.pool.contains( this ))
        println "**** Message.recycle: Message already exists in pool!!!! ****"
      endIf
      data.limit_capacity( 1024 )  # Don't let occassional huge messages sit on unused memory
      MessageManager.pool.add( this )

    method release
      --ref_count
      if (not ref_count) MessageManager.pool.add( this )

    method reply->Message
      if (not m_reply) m_reply = Message( message_id )
      return m_reply

    method retain
      # Messages only need to be retain()d if you want to keep a reference to them
      # outside the normal listener callbacks.
      ++ref_count

    method send->Message
      nativeHeader struct RogueByte_List;
      nativeHeader bool NativeInterface_send_message( RogueByte_List* bytes );

      local has_reply : Logical
      native @|$has_reply = NativeInterface_send_message( $this->data );
      if (has_reply)
        init_from_data  # reply has been placed in same Byte[] buffer
        return this
      else
        recycle
        return null
      endIf

    method to->Byte[]
      return data

    method write_byte( value:Int32 )
      data.add( value )

    method write_int32( value:Int32 )
      # Writes 4 bytes in high-low order, e.g. 0x12345678 -> [12,34,56,78]
      data.add( value:>>>:24 )
      data.add( value:>>>:16 )
      data.add( value:>>>:8 )
      data.add( value )

    method write_int32x( value:Int32 )
      # Writes a variable-length encoded value that is stored in 1..5 bytes.
      # See read_int32x() for more details.
      if (value >= -64 and value < 128)
        data.add( value )
      else
        local extra_bytes = 1
        local shift = 7
        local min = -0x1000
        local max =  0x0FFF
        loop 3
          if (value >= min and value <= max) escapeLoop
          ++extra_bytes
          shift += 7
          min = min :<<: 7
          max = (max :<<: 7) | 0xFF
        endLoop
        write_byte( 0b10_000000 | ((value:>>>:shift)&0b11_1111) )
        loop extra_bytes-1
          shift -= 7
          write_byte( 0b1000_0000 | ((value:>>>:shift) & 0b0111_1111) )
        endLoop
        shift -= 7
        write_byte( (value:>>>:shift) & 0b0111_1111 )
      endIf

    method write_real64( value:Real64 )
      # Writes 4 bytes in high-low order, e.g. 0x12345678 -> [12,34,56,78]
      local bits = value.integer_bits
      write_int32( bits :>>: 32 )
      write_int32( bits )

    method write_string( value:String )
      write_int32x( value.count )
      write_int32x( forEach in value )

endClass
