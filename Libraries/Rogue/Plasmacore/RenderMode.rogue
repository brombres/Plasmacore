module Plasmacore

class RenderMode
  DEFINITIONS
    BLEND_NONE          = -1
    BLEND_ZERO          =  0
    BLEND_ONE           =  1
    BLEND_ALPHA         =  2
    BLEND_INVERSE_ALPHA =  3

    SHAPE_LINES         =  2
    SHAPE_TRIANGLES     =  3

  GLOBAL PROPERTIES
    LINES             : RenderMode
    POLYGONS          : RenderMode
    TEXTURED_POLYGONS : RenderMode
    COLOR_MULTIPLIED_TEXTURED_POLYGONS : RenderMode

  GLOBAL METHODS
    method COLOR_MULTIPLIED_TEXTURED_POLYGONS->RenderMode
      if (@COLOR_MULTIPLIED_TEXTURED_POLYGONS) return @COLOR_MULTIPLIED_TEXTURED_POLYGONS
      COLOR_MULTIPLIED_TEXTURED_POLYGONS = RenderMode( "colorMultipliedTexturedVertexShader",
          "colorMultipliedTexturedFragmentShader", RenderMode.BLEND_ONE )
      return @COLOR_MULTIPLIED_TEXTURED_POLYGONS

    method LINES->RenderMode
      if (@LINES) return @LINES
      LINES = RenderMode( "coloredVertexShader", "coloredFragmentShader", RenderMode.BLEND_ALPHA )
      @LINES.shape = SHAPE_LINES
      return @LINES

    method POLYGONS->RenderMode
      if (@POLYGONS) return @POLYGONS
      POLYGONS = RenderMode( "coloredVertexShader", "coloredFragmentShader", RenderMode.BLEND_ALPHA )
      return @POLYGONS

    method TEXTURED_POLYGONS->RenderMode
      if (@TEXTURED_POLYGONS) return @TEXTURED_POLYGONS
      TEXTURED_POLYGONS = RenderMode( "texturedVertexShader", "texturedFragmentShader", RenderMode.BLEND_ONE )
      return @TEXTURED_POLYGONS

  PROPERTIES
    id                   : Int32
    is_modified          = false
    source_blend         : Int32
    destination_blend    : Int32
    shape                = SHAPE_TRIANGLES : Int32
    vertex_shader_name   : String
    fragment_shader_name : String

    texture     : Texture
    positions   = XYZ[]
    colors      = Color[]
    uvs         = XY[]

  METHODS
    method init( vertex_shader_name, fragment_shader_name,
        source_blend=RenderMode.BLEND_ONE, destination_blend=RenderMode.BLEND_INVERSE_ALPHA )
      id = RenderModeManager.next_id
      ++RenderModeManager.next_id
      mark_modified

    method on_cleanup
      Message("RenderMode.undefine").[ write_int32x(id) ].send

    method activate
      if (this is Canvas.render_mode and not is_modified) return

      local q = Canvas.render_queue
      if (is_modified)
        q.write( RenderCmd.DEFINE_RENDER_MODE )
        q.write_int32x( id )
        q.write_int32x( shape )
        q.write_int32x( source_blend )
        q.write_int32x( destination_blend )
        q.write_string( vertex_shader_name )
        q.write_string( fragment_shader_name )
      endIf

      Canvas.@render_mode = this
      q.write( RenderCmd.USE_RENDER_MODE )
      q.write_int32x( id )

    method add_color( color:Color )
      colors.add( color )

    method add_colors( a:Color, b:Color )
      colors.add( a )
      colors.add( b )

    method add_colors( a:Color, b:Color, c:Color )
      colors.add( a )
      colors.add( b )
      colors.add( c )

    method add_position( xyz:XYZ )
      positions.add( xyz )

    method add_positions( a:XYZ, b:XYZ )
      positions.add( a )
      positions.add( b )

    method add_positions( a:XYZ, b:XYZ, c:XYZ )
      positions.add( a )
      positions.add( b )
      positions.add( c )

    method add_uv( uv:XY )
      uvs.add( uv )

    method add_uvs( a:XY, b:XY )
      uvs.add( a )
      uvs.add( b )

    method add_uvs( a:XY, b:XY, c:XY )
      uvs.add( a )
      uvs.add( b )
      uvs.add( c )

    method color->Color
      if (colors.is_empty) return Color.WHITE
      return colors.first

    method commit
      local q = Canvas.render_queue

      if (texture)
        # Texture must be changed before sending other data because it may
        # flush any queued data
        q.write( RenderCmd.USE_TEXTURE )
        q.write_int32x( texture.id )
        texture = null
      endIf

      if (positions.count)
        q.write( RenderCmd.PUSH_POSITIONS )
        q.write_int32x( positions.count )
        q.write( forEach in positions )
        positions.clear
      endIf

      if (colors.count)
        q.write( RenderCmd.PUSH_COLORS )
        q.write_int32x( colors.count )
        q.write( forEach in colors )
        colors.clear
      endIf

      if (uvs.count)
        q.write( RenderCmd.PUSH_UVS )
        q.write_int32x( uvs.count )
        q.write( forEach in uvs )
        uvs.clear
      endIf

    method draw( image:Image, position:XY, rotation=null:Radians?, anchor=Anchor.CENTER:Anchor, color=null:Color? )
      if (color)
        loop (6) colors.add( color.value )
      endIf
      image.draw( position, rotation, anchor, this )

    method draw( image:Image, position:XY, rotation=null:Radians?, anchor=Anchor.CENTER:Anchor, colors=null:Quad<<Color>>? )
      if (colors)
        this.colors.add( colors.value.a )
        this.colors.add( colors.value.c )
        this.colors.add( colors.value.b )
        this.colors.add( colors.value.a )
        this.colors.add( colors.value.d )
        this.colors.add( colors.value.c )
      endIf
      image.draw( position, rotation, anchor, this )

    method draw( image:Image, position:XY, rotation:Matrix, anchor=Anchor.CENTER:Anchor, color=null:Color? )
      if (color)
        loop (6) colors.add( color.value )
      endIf
      image.draw( position, rotation, anchor, this )

    method draw( image:Image, position:XY, rotation:Matrix, anchor=Anchor.CENTER:Anchor, colors=null:Quad<<Color>>? )
      if (colors)
        this.colors.add( colors.value.a )
        this.colors.add( colors.value.c )
        this.colors.add( colors.value.b )
        this.colors.add( colors.value.a )
        this.colors.add( colors.value.d )
        this.colors.add( colors.value.c )
      endIf
      image.draw( position, rotation, anchor, this )

    method mark_modified
      if (is_modified) return
      is_modified = true

    method on_use->this
      activate
      return this

    method on_end_use
      commit

    method set_color( color:Color )
      colors.clear
      colors.add( color )
      # Note: does not need to mark_modified; colors are part of vertex definitions,
      # not the render mode definition.

    method set_opacity( p:Real64 )
      if (colors.is_empty)
        colors.add( ((p*255)->Int32 :<<: 24) | 0xFFffFF )
      else
        forEach (color at i in colors)
          colors[i] = color.with_opacity(p)
        endForEach
      endIf

    method set_source_blend( @source_blend )
      mark_modified

    method set_destination_blend( @destination_blend )
      mark_modified

    method set_shape( @shape )
      mark_modified

    method set_vertex_shader_name( @vertex_shader_name )
      mark_modified

    method set_fragment_shader_name( @fragment_shader_name )
      mark_modified


endClass

class RenderModeManager [singleton]
  PROPERTIES
    next_id         = 1
endClass

