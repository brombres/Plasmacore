module Plasmacore

uses Vulkan

$include LunarG

class VulkanRenderer : Renderer [essential abstract singleton]
  PROPERTIES
    context = VKContext()

    textures = VKTextureImage[]  # FIXME: only needed during development to port demo

  METHODS
    method init_object
      context.swapchain = VKSwapchain( context, Display.size )

    method begin_render [override]
      #swapchain.prepare
      #swapchain.block_until_ready

    method configure
trace "----"
      # Identifying your app allows driver manufacturers to potentially optimize Vulkan drivers for your game.
      local app_name = "Plasmacore App"
      local app_version_code = 1

      local app_info = VKApplicationInfo( app_name, app_version_code, "Plasmacore2023", Plasmacore.VERSION_CODE )

      local create_info = VKInstanceConfig( context, app_info )
      create_info.enable_extension( "VK_KHR_get_physical_device_properties2" )
      create_info.enable_extension( "VK_KHR_surface" )
      create_info.enable_extension( "VK_EXT_metal_surface" )
      create_info.enable_extension( "VK_KHR_portability_enumeration" )

      context.instance = VKInstance( create_info )

      local preferred_device_order =
      [
        VKDeviceType.DISCRETE_GPU
        VKDeviceType.INTEGRATED_GPU
        VKDeviceType.VIRTUAL_GPU
        VKDeviceType.CPU
        VKDeviceType.OTHER
      ]

      local gpus = context.instance.gpus

      forEach (search_type in preferred_device_order)
        if local found_device = gpus.first( (device) => (device.type == search_type) )
          context.gpu = found_device
          escapeForEach
        endIf
      endForEach

      if (context.gpu)
        log.println "[Vulkan] Using GPU $"(context.gpu)
      else
        error.println "[Vulkan] ERROR: no GPU found"
      endIf

    method configure_surface
      block
        # Find a queue family that supports both graphics and presentation
        forEach (family in context.gpu.queue_families)
          if (family.supports_graphics and family.supports_presenting)
            context.graphics_queue_family = family
            context.presentation_queue_family = family
            escapeBlock
          endIf
        endForEach

        # Find separate queue families for graphics and for presentation
        forEach (family in context.gpu.queue_families)
          if (family.supports_graphics)
            context.graphics_queue_family = family
            escapeForEach
          endIf
        endForEach

        forEach (family in context.gpu.queue_families)
          if (family.supports_presenting)
            context.presentation_queue_family = family
            escapeBlock
          endIf
        endForEach

      endBlock

      context.uses_separate_presentation_queue =
          (context.graphics_queue_family.index != context.presentation_queue_family.index)

      block
        local desired_formats =
        [
          VKFormat.R8G8B8A8_UNORM,
          VKFormat.B8G8R8A8_UNORM,
          VKFormat.A2B10G10R10_UNORM_PACK32,
          VKFormat.A2R10G10B10_UNORM_PACK32,
          VKFormat.R16G16B16A16_SFLOAT
        ]
        forEach (desired_format in desired_formats)
          if local format = context.surface.formats.first( $.format == desired_format )
            context.surface_format = format
            escapeBlock
          endIf
        endForEach

        context.surface_format = context.surface.formats.first
      endBlock

    method create_device
      trace "----"

      local config = VKDeviceConfig( context )
      config.enable_extension( "VK_KHR_swapchain" )
      config.enable_extension( "VK_KHR_incremental_present" )
      config.enable_extension( "VK_KHR_portability_subset" )
      context.device = VKDevice( config )

      #swapchain = VKSwapchain( this, 3, 2 )

    method create_surface
      noAction

    method dispatch_create_device [api]
      create_device

    method dispatch_load_assets [api]
      trace "----"
      textures.add( load_texture(LunarG.bitmap) )

    method dispatch_prepare [api]
      prepare

    method dispatch_create_surface [api]
      create_surface
      configure_surface

    method dispatch_reset [api]
      reset

    method end_render [override]
      trace "----"
      #swapchain.advance_frame

    method load_texture( bitmap:Bitmap )->VKTextureImage
      return VKTextureImage( context, bitmap )

      #{
    method load_texture( file:File )->VKTextureImage
      trace "TODO " file
      return null

    method load_texture( bytes:Byte[] )->VKTextureImage
      local buffer = context.device.create_buffer(
      return null
      }#

    method prepare
      context.swapchain.configure

      if (context.is_minimized)
        context.is_prepared = false
        return
      endIf

      local size = context.swapchain.surface_size
      context.depth_stencil =
        VKAllocatedImage(
          context,
          size,
          VKFormat.D16_UNORM,
          VKImageUsage.DEPTH_STENCIL_ATTACHMENT,
          VKImageAspect.DEPTH
        )

    method reset
      context.reset
endClass
