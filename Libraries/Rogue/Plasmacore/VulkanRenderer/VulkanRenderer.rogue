module Plasmacore

uses Vulkan

class VulkanRenderer : Renderer [essential abstract singleton]
  PROPERTIES
    instance   : VKInstance

    native "VkPresentModeKHR present_mode;"

    surface    : VKSurface

    gpu_info   : VKGPUInfo
    gpu_number = -1
    device     : VKDevice

    uses_separate_presentation_queue : Logical

    graphics_queue_family            : VKQueueFamily
    presentation_queue_family        : VKQueueFamily
    surface_format                   : VKSurfaceFormat
    swapchain                        : VKSwapchain

    surface_formats : VKSurfaceFormat[]

    native "PFN_vkGetDeviceProcAddr                       vkGetDeviceProcAddr;"
    native "PFN_vkGetPhysicalDeviceSurfaceSupportKHR      vkGetPhysicalDeviceSurfaceSupportKHR;"
    native "PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR vkGetPhysicalDeviceSurfaceCapabilitiesKHR;"
    native "PFN_vkGetPhysicalDeviceSurfaceFormatsKHR      vkGetPhysicalDeviceSurfaceFormatsKHR;"
    native "PFN_vkGetPhysicalDeviceSurfacePresentModesKHR vkGetPhysicalDeviceSurfacePresentModesKHR;"
    native "PFN_vkGetSwapchainImagesKHR                   vkGetSwapchainImagesKHR;"

    is_configured : Logical

  METHODS
    method init_object
      native @|$this->present_mode = VK_PRESENT_MODE_FIFO_KHR;

    method begin_render [override]
      swapchain.prepare
      swapchain.block_until_ready

    method configure [api]
      trace "---- configure"
      if (is_configured) return
      is_configured = true

      # Identifying your app allows driver manufacturers to potentially optimize Vulkan drivers for your game.
      local app_name = "Plasmacore App"
      local app_version_code = 1

      local app_info = VKApplicationInfo( app_name, app_version_code, "Plasmacore2023", Plasmacore.VERSION_CODE )

      local create_info = VKInstanceCreateInfo( app_info )
      create_info.enable_extension( "VK_KHR_get_physical_device_properties2" )
      create_info.enable_extension( "VK_KHR_surface" )
      create_info.enable_extension( "VK_EXT_metal_surface" )
      create_info.enable_extension( "VK_KHR_portability_enumeration" )

      instance = VKInstance( create_info )

      local fn = instance.device_procedure_address( "vkGetDeviceProcAddr" )
      native @|$this->vkGetDeviceProcAddr = (PFN_vkGetDeviceProcAddr) $fn.value;

      fn = instance.device_procedure_address( "vkGetPhysicalDeviceSurfaceSupportKHR" )
      native @|$this->vkGetPhysicalDeviceSurfaceSupportKHR = (PFN_vkGetPhysicalDeviceSurfaceSupportKHR) $fn.value;

      fn = instance.device_procedure_address( "vkGetPhysicalDeviceSurfaceCapabilitiesKHR" )
      native @|$this->vkGetPhysicalDeviceSurfaceCapabilitiesKHR = (PFN_vkGetPhysicalDeviceSurfaceCapabilitiesKHR) $fn.value;

      fn = instance.device_procedure_address( "vkGetPhysicalDeviceSurfaceFormatsKHR" )
      native @|$this->vkGetPhysicalDeviceSurfaceFormatsKHR = (PFN_vkGetPhysicalDeviceSurfaceFormatsKHR) $fn.value;

      fn = instance.device_procedure_address( "vkGetPhysicalDeviceSurfacePresentModesKHR" )
      native @|$this->vkGetPhysicalDeviceSurfacePresentModesKHR = (PFN_vkGetPhysicalDeviceSurfacePresentModesKHR) $fn.value;

      fn = instance.device_procedure_address( "vkGetSwapchainImagesKHR" )
      native @|$this->vkGetSwapchainImagesKHR = (PFN_vkGetSwapchainImagesKHR) $fn.value;

      local preferred_device_order =
      [
        VKGPUType.DISCRETE_GPU
        VKGPUType.INTEGRATED_GPU
        VKGPUType.VIRTUAL_GPU
        VKGPUType.CPU
        VKGPUType.OTHER
      ]

      local devices = instance.physical_devices
      forEach (search_type in preferred_device_order)
        if local found_device = devices.first( (info) with (search_type) => info.type == search_type )
          gpu_info = found_device
          gpu_number = found_device.index
          escapeForEach
        endIf
      endForEach

      if (gpu_info)
        log.println "[Vulkan] Using GPU $"(gpu_info)
        gpu_info.enable_extension( "VK_KHR_swapchain" )
        gpu_info.enable_extension( "VK_KHR_portability_subset" )
      else
        error.println "[Vulkan] ERROR: no GPU found"
      endIf

    method create_device [api]
      if (not gpu_info) return

      local config = gpu_info.device_configuration
      config.enable_extension( "VK_KHR_swapchain" )
      config.enable_extension( "VK_KHR_portability_subset" )
      device = config.create_device

      block
        local desired_formats =
        [
          VKBitFormat.R8G8B8A8_UNORM,
          VKBitFormat.B8G8R8A8_UNORM,
          VKBitFormat.A2B10G10R10_UNORM_PACK32,
          VKBitFormat.A2R10G10B10_UNORM_PACK32,
          VKBitFormat.R16G16B16A16_SFLOAT
        ]
        forEach (desired_format in desired_formats)
          if local format = surface_formats.first( $.bit_format == desired_format )
            surface_format = format
            escapeBlock
          endIf
        endForEach

        surface_format = surface_formats.first
      endBlock

      swapchain = VKSwapchain( this )

    method create_surface [abstract api]

    method end_render [override]
      swapchain.advance_frame

    method find_queue_families
      block
        # Find a queue family that supports both graphics and presentation
        forEach (family in gpu_info.queue_families)
          if (family.supports_graphics and family.supports_presenting)
            graphics_queue_family = family
            presentation_queue_family = family
            escapeBlock
          endIf
        endForEach

        # Find separate queue families for graphics and for presentation
        forEach (family in gpu_info.queue_families)
          if (family.supports_graphics)
            graphics_queue_family = family
            escapeForEach
          endIf
        endForEach

        forEach (family in gpu_info.queue_families)
          if (family.supports_presenting)
            presentation_queue_family = family
            escapeBlock
          endIf
        endForEach

      endBlock

      uses_separate_presentation_queue = (graphics_queue_family.index != presentation_queue_family.index)

    method surface_formats->VKSurfaceFormat[]
      if (@surface_formats) return @surface_formats

      local result = VKSurfaceFormat[]
      native
        @|uint32_t count = 0;
         |$this->vkGetPhysicalDeviceSurfaceFormatsKHR( $gpu_info->gpu, $this->surface->value, &count, NULL);
         |if (count && count < 200)
         |{
         |  VkSurfaceFormatKHR formats[200];
         |  int i;
         |  $this->vkGetPhysicalDeviceSurfaceFormatsKHR( $gpu_info->gpu, $this->surface->value, &count, formats);
         |  for (i=0; i<count; ++i)
         |  {
              local format : VKSurfaceFormat
      native
        @|    $format.value = formats[i];
              result.add( format )
      native
        @|  }
         |}

         @surface_formats = result
         return @surface_formats
endClass
