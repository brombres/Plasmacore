module Plasmacore

uses Vulkan

$include VulkanRenderer/PVKSwapchain


class VulkanRenderer : Renderer [essential abstract singleton]
  PROPERTIES
    context    = VKContext()

    swapchain  = PVKSwapchain( this )

    uses_separate_presentation_queue : Logical

    graphics_queue_family            : VKQueueFamily
    presentation_queue_family        : VKQueueFamily
    surface_format                   : VKSurfaceFormat
    #swapchain                        : VKSwapchain

    #surface_formats : VKSurfaceFormat[]

  METHODS
    method begin_render [override]
      #swapchain.prepare
      #swapchain.block_until_ready

    method configure [api]
trace "----"
      # Identifying your app allows driver manufacturers to potentially optimize Vulkan drivers for your game.
      local app_name = "Plasmacore App"
      local app_version_code = 1

      local app_info = VKApplicationInfo( app_name, app_version_code, "Plasmacore2023", Plasmacore.VERSION_CODE )

      local create_info = VKInstanceCreateInfo( context, app_info )
      create_info.enable_extension( "VK_KHR_get_physical_device_properties2" )
      create_info.enable_extension( "VK_KHR_surface" )
      create_info.enable_extension( "VK_EXT_metal_surface" )
      create_info.enable_extension( "VK_KHR_portability_enumeration" )

      context.instance = VKInstance( create_info )

      local preferred_device_order =
      [
        VKDeviceType.DISCRETE_GPU
        VKDeviceType.INTEGRATED_GPU
        VKDeviceType.VIRTUAL_GPU
        VKDeviceType.CPU
        VKDeviceType.OTHER
      ]

      local devices = context.instance.physical_devices
      trace devices

      #{
      forEach (search_type in preferred_device_order)
        if local found_device = devices.first( (device) => (device.type == search_type) )
          context.gpu = found_device
          gpu_number = found_device.index
          escapeForEach
        endIf
      endForEach

      if (context.gpu)
        log.println "[Vulkan] Using GPU $"(context.gpu)
      else
        error.println "[Vulkan] ERROR: no GPU found"
      endIf
      }#

    method configure_device( native_device:VKNativeDevice ) [api]
trace "----"
      context.device = VKDevice( context, native_device )
#{
      if (not gpu) return

      local config = VKDeviceCreateInfo( gpu )
      config.enable_extension( "VK_KHR_swapchain" )
      config.enable_extension( "VK_KHR_portability_subset" )

      device = VKDevice( config )

      local fn = device.procedure_address( "vkCreateSwapchainKHR" )
      native @|$this->vkCreateSwapchainKHR    = (PFN_vkCreateSwapchainKHR) $fn.value;

      fn = device.procedure_address( "vkDestroySwapchainKHR" )
      native @|$this->vkDestroySwapchainKHR   = (PFN_vkDestroySwapchainKHR) $fn.value;

      fn = device.procedure_address( "vkGetSwapchainImagesKHR" )
      native @|$this->vkGetSwapchainImagesKHR = (PFN_vkGetSwapchainImagesKHR) $fn.value;

      fn = device.procedure_address( "vkAcquireNextImageKHR" )
      native @|$this->vkAcquireNextImageKHR   = (PFN_vkAcquireNextImageKHR) $fn.value;

      fn = device.procedure_address( "vkQueuePresentKHR" )
      native @|$this->vkQueuePresentKHR       = (PFN_vkQueuePresentKHR) $fn.value;

      block
        local desired_formats =
        [
          VKBitFormat.R8G8B8A8_UNORM,
          VKBitFormat.B8G8R8A8_UNORM,
          VKBitFormat.A2B10G10R10_UNORM_PACK32,
          VKBitFormat.A2R10G10B10_UNORM_PACK32,
          VKBitFormat.R16G16B16A16_SFLOAT
        ]
        forEach (desired_format in desired_formats)
          if local format = surface_formats.first( $.bit_format == desired_format )
            surface_format = format
            escapeBlock
          endIf
        endForEach

        surface_format = surface_formats.first
      endBlock

      #swapchain = VKSwapchain( this, 3, 2 )
}#

    method configure_gpu( native_gpu:VKNativeGPU, gpu_number:Int32 ) [api]
trace "----"
      context.gpu = VKGPU( context, native_gpu, gpu_number )

    method create_surface [abstract api]

    method end_render [override]
      trace "----"
      #swapchain.advance_frame

    method find_queue_families
      block
        # Find a queue family that supports both graphics and presentation
        forEach (family in gpu.queue_families)
          if (family.supports_graphics and family.supports_presenting)
            graphics_queue_family = family
            presentation_queue_family = family
            escapeBlock
          endIf
        endForEach

        # Find separate queue families for graphics and for presentation
        forEach (family in gpu.queue_families)
          if (family.supports_graphics)
            graphics_queue_family = family
            escapeForEach
          endIf
        endForEach

        forEach (family in gpu.queue_families)
          if (family.supports_presenting)
            presentation_queue_family = family
            escapeBlock
          endIf
        endForEach

      endBlock

      uses_separate_presentation_queue = (graphics_queue_family.index != presentation_queue_family.index)

      #{
    method surface_formats->VKSurfaceFormat[]
      if (@surface_formats) return @surface_formats

      local result = VKSurfaceFormat[]
      native
        @|uint32_t count = 0;
         |$this->vkGetPhysicalDeviceSurfaceFormatsKHR( $gpu->device_value, $this->surface->value, &count, NULL);
         |if (count && count < 200)
         |{
         |  VkSurfaceFormatKHR formats[200];
         |  int i;
         |  $this->vkGetPhysicalDeviceSurfaceFormatsKHR( $gpu->device_value, $this->surface->value, &count, formats);
         |  for (i=0; i<count; ++i)
         |  {
              local format : VKSurfaceFormat
      native
        @|    $format.value = formats[i];
              result.add( format )
      native
        @|  }
         |}

         @surface_formats = result
         return @surface_formats
         }#
endClass
