$include "Libraries/Rogue/Plasmacore"
uses Plasmacore

println "** Rogue **"

class Cube [singleton]
  PROPERTIES
    rotation : Real64
    image    : Image

  METHODS
    method init
      image = Image( Bitmap(ImageAsset("Max.png")) )

    method update
      rotation += 0.005
endClass

Plasmacore.on_configure = (() => println("Configuring"))

Plasmacore.on_update = (() => Cube.update)

Plasmacore.on_draw =
  function
    Canvas.clear( Color.GRAY )
    Canvas.bounds.cropped( Canvas.width/4, Canvas.height/4, Canvas.width/4, Canvas.height/4 ).fill(
      Quad<<Color>>(Color.YELLOW, Color.RED, Color.GREEN, Color.BLUE) )
    local color = Color.MAGENTA.with_opacity( 0.25 )
    Triangle( Canvas.at(0.5,0.1), Canvas.at(0.25,0.9), Canvas.at(0.75,0.9) ).fill( color )

    #Canvas.clear( Color.BLACK )
    forEach (i in 0..100 step 10)
      local p = i / 100.0
      Line( Canvas.at(0,p), Canvas.at(p,1) ).draw( Color.GREEN )
    endForEach

    if (Cube.image.is_loaded)
      Cube.image.scale = 0.25
      #Cube.image.rotation = Degrees(22.5)
      #Cube.image.anchor = Anchor.RIGHT
      Cube.image.draw( Canvas.center, Anchor.CENTER )
      #local render_mode = RenderMode.COLOR_MULTIPLIED_TEXTURED_POLYGONS
      #render_mode.draw( Cube.image, Canvas.center, Matrix.rotate(Cube.rotation,XYZ(1,0,0)), Anchor.RIGHT, Color.WHITE.with_opacity(0.25))
      #render_mode.draw( Cube.image, Canvas.center, Matrix.rotate(Cube.rotation+pi,XYZ(1,0,0)), Anchor.RIGHT, Color.BLUE )
    endIf
  endFunction

  #@trace Plasmacore.find_asset_filepath("Images/Max.png")
  #@trace Plasmacore.find_asset_filepath("Assets/Images/Max.png")
  #Texture( "Images/Max.png" )
Cube

routine abs( filepath:String )->String
  if (not filepath) return null
  filepath = File.expand_path( filepath )

  if (not File.exists(filepath))
    local parent = File.folder( filepath )
    if (parent.count == 0) parent = "."
    return "$/$" (File.absolute_filepath(parent),File.filename(filepath))
  endIf

  local return_value : String

  native @|#if defined(_WIN32)
          |{
          |  char long_name[PATH_MAX+4];
          |  char full_name[PATH_MAX+4];
          |
          |  strcpy_s( long_name, PATH_MAX+4, (char*)$filepath->utf8 );
          |
          |  if (GetFullPathName(long_name, PATH_MAX+4, full_name, 0) != 0)
          |  {
          |printf("Set return value 1\n");
          |    $return_value = RogueString_create_from_utf8( full_name, -1 );
          |  }
          |}
          |#else
          |{
          |  int original_dir_fd;
          |  int new_dir_fd;
          |  char filename[PATH_MAX];
          |  char c_filepath[ PATH_MAX ];
          |  bool is_folder;
          |
          |  is_folder = RogueFile__is_folder__String( $filepath );
          |
          |  int len = $filepath->byte_count;
          |  if (len >= PATH_MAX) len = PATH_MAX - 1;
          |  memcpy( c_filepath, (char*)$filepath->utf8, len );
          |  c_filepath[len] = 0;
          |
          |  // A way to get back to the starting folder when finished.
          |  original_dir_fd = open( ".", O_RDONLY );
          |
          |  if (is_folder)
          |  {
          |    filename[0] = 0;
          |  }
          |  else
          |  {
          |    // fchdir only works with a path, not a path+filename (c_filepath).
          |    // Copy out the filename and null terminate the filepath to be just a path.
          |    int i = (int) strlen( c_filepath ) - 1;
          |    while (i >= 0 && c_filepath[i] != '/') --i;
          |    strcpy( filename, c_filepath+i+1 );
          |    if (i == -1) strcpy( c_filepath, "." );
          |    else         c_filepath[i] = 0;
          |  }
          |  new_dir_fd = open( c_filepath, O_RDONLY );
          |printf("new fd:%d\n", new_dir_fd);
          |
          |  do
          |  {
          |    if (original_dir_fd < 0 || new_dir_fd < 0) break;
          |      int r = fchdir( new_dir_fd );
          |if (r != 0) { printf("break 1\n"); }
          |      if ( r != 0 ) break;
          |      char * r2 = getcwd( c_filepath, PATH_MAX );
          |if (r2 == 0) { printf("break 2\n"); }
          |      if ( r2 == 0 ) break;
          |      if ( !is_folder )
          |      {
          |printf("repairing c_filepath\n");
          |        strcat( c_filepath, "/" );
          |        strcat( c_filepath, filename );
          |      }
          |      r = fchdir( original_dir_fd );
          |if (r != 0) { printf("break 3\n"); }
          |      if ( r != 0 ) break;
          |
          |printf("Set return value 2\n");
          |    $return_value = RogueString_create_from_utf8( c_filepath, -1 );
          |  } while (false);
          |
          |  if (original_dir_fd >= 0) close( original_dir_fd );
          |  if (new_dir_fd >= 0) close( new_dir_fd );
          |}
          |#endif

trace return_value
  if (return_value is null)
    throw IOError("Could not get absolute path")
  endIf

  return File.fix_slashes( return_value )
endRoutine
